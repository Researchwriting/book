"""
Auto-Notifier - Send completed sections via email or cloud storage
"""
import os
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
import shutil
from pathlib import Path

class AutoNotifier:
    def __init__(self, config: dict = None):
        """
        Initialize auto-notifier.
        
        Config options:
        - email_enabled: bool
        - email_to: str (recipient email)
        - email_from: str (sender email)
        - email_password: str (app password)
        - email_smtp: str (SMTP server, default: smtp.gmail.com)
        - email_port: int (default: 587)
        - backup_enabled: bool
        - backup_path: str (path to backup directory)
        """
        self.config = config or {}
        self.email_enabled = self.config.get('email_enabled', False)
        self.backup_enabled = self.config.get('backup_enabled', False)
    
    def notify_section_complete(self, section_file: str, section_num: str, section_title: str):
        """
        Send notification when a section is completed.
        
        Args:
            section_file: Path to the completed section file
            section_num: Section number
            section_title: Section title
        """
        print(f"\nüìß Auto-notification for Section {section_num}...")
        
        success = []
        
        # Email notification
        if self.email_enabled:
            if self._send_email(section_file, section_num, section_title):
                success.append("email")
                print(f"   ‚úÖ Email sent to {self.config.get('email_to')}")
            else:
                print(f"   ‚ùå Email failed")
        
        # Backup to cloud/external drive
        if self.backup_enabled:
            if self._backup_file(section_file, section_num):
                success.append("backup")
                print(f"   ‚úÖ Backed up to {self.config.get('backup_path')}")
            else:
                print(f"   ‚ùå Backup failed")
        
        if not success:
            print(f"   ‚ö†Ô∏è  No notifications configured")
        
        return success
    
    def _send_email(self, section_file: str, section_num: str, section_title: str) -> bool:
        """Send email with section attached (both MD and DOCX)."""
        try:
            # Get file size
            file_size = os.path.getsize(section_file) / 1024  # KB
            
            # Create message
            msg = MIMEMultipart()
            msg['From'] = self.config.get('email_from')
            msg['To'] = self.config.get('email_to')
            msg['Subject'] = f"‚úÖ Section {section_num} Complete: {section_title}"
            
            # Email body
            with open(section_file, 'r', encoding='utf-8') as f:
                word_count = len(f.read().split())
            
            # Check for DOCX file
            docx_file = section_file.replace('.md', '.docx')
            has_docx = os.path.exists(docx_file)
            
            body = f"""
Section {section_num} has been completed!

Title: {section_title}
Word Count: ~{word_count:,} words
File Size: {file_size:.1f} KB

Attached files:
- Markdown (.md) - for editing
- Word Document (.docx) - professionally formatted{' ‚úÖ' if has_docx else ' (not available)'}

The completed section is attached to this email.

---
Auto-generated by Textbook Generator
"""
            msg.attach(MIMEText(body, 'plain'))
            
            # Attach MD file
            with open(section_file, 'rb') as f:
                part = MIMEBase('application', 'octet-stream')
                part.set_payload(f.read())
            
            encoders.encode_base64(part)
            part.add_header(
                'Content-Disposition',
                f'attachment; filename= {os.path.basename(section_file)}'
            )
            msg.attach(part)
            
            # Attach DOCX file if it exists
            if has_docx:
                with open(docx_file, 'rb') as f:
                    part_docx = MIMEBase('application', 'vnd.openxmlformats-officedocument.wordprocessingml.document')
                    part_docx.set_payload(f.read())
                
                encoders.encode_base64(part_docx)
                part_docx.add_header(
                    'Content-Disposition',
                    f'attachment; filename= {os.path.basename(docx_file)}'
                )
                msg.attach(part_docx)
            
            # Send email
            smtp_server = self.config.get('email_smtp', 'smtp.gmail.com')
            smtp_port = self.config.get('email_port', 587)
            
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(
                self.config.get('email_from'),
                self.config.get('email_password')
            )
            server.send_message(msg)
            server.quit()
            
            return True
        
        except Exception as e:
            print(f"   Email error: {e}")
            return False
    
    def _backup_file(self, section_file: str, section_num: str) -> bool:
        """Backup file to specified location."""
        try:
            backup_path = self.config.get('backup_path')
            if not backup_path:
                return False
            
            # Create backup directory if it doesn't exist
            os.makedirs(backup_path, exist_ok=True)
            
            # Copy file
            dest_file = os.path.join(backup_path, os.path.basename(section_file))
            shutil.copy2(section_file, dest_file)
            
            return True
        
        except Exception as e:
            print(f"   Backup error: {e}")
            return False

def setup_notifications():
    """Interactive setup for notifications."""
    print("\n" + "="*70)
    print("üìß AUTO-NOTIFICATION SETUP")
    print("="*70)
    
    config = {}
    
    # Email setup
    print("\n1. Email Notifications")
    email_choice = input("   Enable email notifications? (y/n): ").strip().lower()
    
    if email_choice == 'y':
        config['email_enabled'] = True
        config['email_to'] = input("   Your email address: ").strip()
        config['email_from'] = input("   Sender email (Gmail recommended): ").strip()
        
        print("\n   ‚ö†Ô∏è  For Gmail, use an App Password (not your regular password)")
        print("   Generate one at: https://myaccount.google.com/apppasswords")
        config['email_password'] = input("   App password: ").strip()
        
        # Optional: custom SMTP
        custom_smtp = input("   Use custom SMTP server? (y/n, default: Gmail): ").strip().lower()
        if custom_smtp == 'y':
            config['email_smtp'] = input("   SMTP server: ").strip()
            config['email_port'] = int(input("   SMTP port: ").strip())
    else:
        config['email_enabled'] = False
    
    # Backup setup
    print("\n2. Automatic Backup")
    backup_choice = input("   Enable automatic backup? (y/n): ").strip().lower()
    
    if backup_choice == 'y':
        config['backup_enabled'] = True
        print("\n   Examples:")
        print("   - External drive: /media/username/USB_DRIVE/textbooks")
        print("   - Cloud sync folder: ~/Dropbox/textbooks")
        print("   - Network drive: /mnt/nas/textbooks")
        
        config['backup_path'] = input("   Backup path: ").strip()
        
        # Expand ~ to home directory
        config['backup_path'] = os.path.expanduser(config['backup_path'])
    else:
        config['backup_enabled'] = False
    
    # Save config
    import json
    config_file = 'notification_config.json'
    with open(config_file, 'w') as f:
        json.dump(config, f, indent=2)
    
    print(f"\n‚úÖ Configuration saved to {config_file}")
    print("\nYou can edit this file later to change settings.")
    
    return config

def load_notification_config():
    """Load notification config from file."""
    import json
    config_file = 'notification_config.json'
    
    if os.path.exists(config_file):
        with open(config_file, 'r') as f:
            return json.load(f)
    
    return {}

if __name__ == "__main__":
    setup_notifications()
